from _typeshed import Incomplete
from fontTools.encodings.StandardEncoding import StandardEncoding as StandardEncoding
from fontTools.misc import eexec as eexec
from fontTools.misc.macCreatorType import getMacCreatorAndType as getMacCreatorAndType
from fontTools.misc.textTools import bytechr as bytechr
from fontTools.misc.textTools import byteord as byteord
from fontTools.misc.textTools import bytesjoin as bytesjoin
from fontTools.misc.textTools import tobytes as tobytes

DEBUG: int
haveMacSupport: int

class T1Error(Exception): ...

class T1Font:
    data: Incomplete
    encoding: Incomplete
    def __init__(
        self, path, encoding: str = ..., kind: Incomplete | None = ...
    ) -> None: ...
    def saveAs(self, path, type, dohex: bool = ...) -> None: ...
    def getData(self): ...
    def getGlyphSet(self): ...
    def __getitem__(self, key): ...
    font: Incomplete
    def parse(self) -> None: ...
    def createData(self): ...
    def encode_eexec(self, eexec_dict): ...

def read(path, onlyHeader: bool = ...): ...
def write(path, data, kind: str = ..., dohex: bool = ...) -> None: ...

LWFNCHUNKSIZE: int
HEXLINELENGTH: int

def readLWFN(path, onlyHeader: bool = ...): ...
def readPFB(path, onlyHeader: bool = ...): ...
def readOther(path): ...
def writeLWFN(path, data) -> None: ...
def writePFB(path, data) -> None: ...
def writeOther(path, data, dohex: bool = ...) -> None: ...

EEXECBEGIN: bytes
EEXECEND: Incomplete
EEXECINTERNALEND: bytes
EEXECBEGINMARKER: bytes
EEXECENDMARKER: bytes

def isHex(text): ...
def decryptType1(data): ...
def findEncryptedChunks(data): ...
def deHexString(hexstring): ...
def assertType1(data): ...
def longToString(long): ...
def stringToLong(s): ...

font_dictionary_keys: Incomplete
FontInfo_dictionary_keys: Incomplete
Private_dictionary_keys: Incomplete
hintothers: str
std_subrs: Incomplete
eexec_IV: bytes
char_IV: bytes
RD_value: Incomplete
ND_value: Incomplete
PD_value: Incomplete
