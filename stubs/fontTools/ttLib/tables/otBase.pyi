from enum import IntEnum
from typing import Iterator, NamedTuple, Optional, Tuple

from _typeshed import Incomplete
from fontTools.config import OPTIONS as OPTIONS
from fontTools.misc.textTools import Tag as Tag
from fontTools.misc.textTools import bytesjoin as bytesjoin

from .DefaultTable import DefaultTable as DefaultTable

log: Incomplete
have_uharfbuzz: bool
USE_HARFBUZZ_REPACKER: Incomplete

class OverflowErrorRecord:
    tableType: Incomplete
    LookupListIndex: Incomplete
    SubTableIndex: Incomplete
    itemName: Incomplete
    itemIndex: Incomplete
    def __init__(self, overflowTuple) -> None: ...

class OTLOffsetOverflowError(Exception):
    value: Incomplete
    def __init__(self, overflowErrorRecord) -> None: ...

class RepackerState(IntEnum):
    PURE_FT: int
    HB_FT: int
    FT_FALLBACK: int

class BaseTTXConverter(DefaultTable):
    table: Incomplete
    def decompile(self, data, font) -> None: ...
    def compile(self, font): ...
    def tryPackingHarfbuzz(self, writer, hb_first_error_logged): ...
    def tryPackingFontTools(self, writer): ...
    def tryResolveOverflow(self, font, e, lastOverflowRecord): ...
    def toXML(self, writer, font) -> None: ...
    def fromXML(self, name, attrs, content, font) -> None: ...
    def ensureDecompiled(self, recurse: bool = ...) -> None: ...

class OTTableReader:
    data: Incomplete
    offset: Incomplete
    pos: Incomplete
    localState: Incomplete
    tableTag: Incomplete
    def __init__(
        self,
        data,
        localState: Incomplete | None = ...,
        offset: int = ...,
        tableTag: Incomplete | None = ...,
    ) -> None: ...
    def advance(self, count) -> None: ...
    def seek(self, pos) -> None: ...
    def copy(self): ...
    def getSubReader(self, offset): ...
    def readValue(self, typecode, staticSize): ...
    def readArray(self, typecode, staticSize, count): ...
    def readInt8(self): ...
    def readInt8Array(self, count): ...
    def readShort(self): ...
    def readShortArray(self, count): ...
    def readLong(self): ...
    def readLongArray(self, count): ...
    def readUInt8(self): ...
    def readUInt8Array(self, count): ...
    def readUShort(self): ...
    def readUShortArray(self, count): ...
    def readULong(self): ...
    def readULongArray(self, count): ...
    def readUInt24(self): ...
    def readUInt24Array(self, count): ...
    def readTag(self): ...
    def readData(self, count): ...
    def __setitem__(self, name, value) -> None: ...
    def __getitem__(self, name): ...
    def __contains__(self, name) -> bool: ...

class OTTableWriter:
    items: Incomplete
    pos: Incomplete
    localState: Incomplete
    tableTag: Incomplete
    offsetSize: Incomplete
    parent: Incomplete
    def __init__(
        self,
        localState: Incomplete | None = ...,
        tableTag: Incomplete | None = ...,
        offsetSize: int = ...,
    ) -> None: ...
    @property
    def longOffset(self): ...
    @longOffset.setter
    def longOffset(self, value) -> None: ...
    def __setitem__(self, name, value) -> None: ...
    def __getitem__(self, name): ...
    def __delitem__(self, name) -> None: ...
    def getDataLength(self): ...
    def getData(self): ...
    def getDataForHarfbuzz(self): ...
    def __hash__(self): ...
    def __ne__(self, other): ...
    def __eq__(self, other): ...
    def getAllDataUsingHarfbuzz(self, tableTag): ...
    def getAllData(self, remove_duplicate: bool = ...): ...
    def getSubWriter(self, offsetSize: int = ...): ...
    def writeValue(self, typecode, value) -> None: ...
    def writeArray(self, typecode, values) -> None: ...
    def writeInt8(self, value) -> None: ...
    def writeInt8Array(self, values) -> None: ...
    def writeShort(self, value) -> None: ...
    def writeShortArray(self, values) -> None: ...
    def writeLong(self, value) -> None: ...
    def writeLongArray(self, values) -> None: ...
    def writeUInt8(self, value) -> None: ...
    def writeUInt8Array(self, values) -> None: ...
    def writeUShort(self, value) -> None: ...
    def writeUShortArray(self, values) -> None: ...
    def writeULong(self, value) -> None: ...
    def writeULongArray(self, values) -> None: ...
    def writeUInt24(self, value) -> None: ...
    def writeUInt24Array(self, values) -> None: ...
    def writeTag(self, tag) -> None: ...
    def writeSubTable(self, subWriter) -> None: ...
    def writeCountReference(
        self, table, name, size: int = ..., value: Incomplete | None = ...
    ): ...
    def writeStruct(self, format, values) -> None: ...
    def writeData(self, data) -> None: ...
    def getOverflowErrorRecord(self, item): ...

class CountReference:
    table: Incomplete
    name: Incomplete
    size: Incomplete
    def __init__(
        self, table, name, size: Incomplete | None = ..., value: Incomplete | None = ...
    ) -> None: ...
    def setValue(self, value) -> None: ...
    def getValue(self): ...
    def getCountData(self): ...

def packUInt8(value): ...
def packUShort(value): ...
def packULong(value): ...
def packUInt24(value): ...

class BaseTable:
    def __getattr__(self, attr): ...
    def ensureDecompiled(self, recurse: bool = ...) -> None: ...
    @classmethod
    def getRecordSize(cls, reader): ...
    def getConverters(self): ...
    def getConverterByName(self, name): ...
    def populateDefaults(self, propagator: Incomplete | None = ...) -> None: ...
    def decompile(self, reader, font) -> None: ...
    def compile(self, writer, font) -> None: ...
    def readFormat(self, reader) -> None: ...
    def writeFormat(self, writer) -> None: ...
    def toXML(
        self,
        xmlWriter,
        font,
        attrs: Incomplete | None = ...,
        name: Incomplete | None = ...,
    ) -> None: ...
    def toXML2(self, xmlWriter, font) -> None: ...
    def fromXML(self, name, attrs, content, font) -> None: ...
    def __ne__(self, other): ...
    def __eq__(self, other): ...

    class SubTableEntry(NamedTuple):
        name: str
        value: BaseTable
        index: Optional[int]
    def iterSubTables(self) -> Iterator[SubTableEntry]: ...
    def getVariableAttrs(self): ...

class FormatSwitchingBaseTable(BaseTable):
    @classmethod
    def getRecordSize(cls, reader): ...
    def getConverters(self): ...
    def getConverterByName(self, name): ...
    Format: Incomplete
    def readFormat(self, reader) -> None: ...
    def writeFormat(self, writer) -> None: ...
    def toXML(
        self,
        xmlWriter,
        font,
        attrs: Incomplete | None = ...,
        name: Incomplete | None = ...,
    ) -> None: ...
    def getVariableAttrs(self): ...

class UInt8FormatSwitchingBaseTable(FormatSwitchingBaseTable):
    Format: Incomplete
    def readFormat(self, reader) -> None: ...
    def writeFormat(self, writer) -> None: ...

formatSwitchingBaseTables: Incomplete

def getFormatSwitchingBaseTableClass(formatType): ...
def getVariableAttrs(cls, fmt: Optional[int] = ...) -> Tuple[str]: ...

valueRecordFormat: Incomplete
valueRecordFormatDict: Incomplete

class ValueRecordFactory:
    format: Incomplete
    def __init__(self, valueFormat) -> None: ...
    def __len__(self) -> int: ...
    def readValueRecord(self, reader, font): ...
    def writeValueRecord(self, writer, font, valueRecord) -> None: ...

class ValueRecord:
    __dict__: Incomplete
    def __init__(
        self, valueFormat: Incomplete | None = ..., src: Incomplete | None = ...
    ) -> None: ...
    def getFormat(self): ...
    def getEffectiveFormat(self): ...
    def toXML(
        self, xmlWriter, font, valueName, attrs: Incomplete | None = ...
    ) -> None: ...
    def fromXML(self, name, attrs, content, font) -> None: ...
    def __ne__(self, other): ...
    def __eq__(self, other): ...
