from _typeshed import Incomplete
from fontTools.feaLib.error import FeatureLibError as FeatureLibError
from fontTools.feaLib.lexer import IncludingLexer as IncludingLexer
from fontTools.feaLib.lexer import Lexer as Lexer
from fontTools.feaLib.lexer import NonIncludingLexer as NonIncludingLexer
from fontTools.feaLib.variableScalar import VariableScalar as VariableScalar
from fontTools.misc.encodingTools import getEncoding as getEncoding
from fontTools.misc.textTools import bytechr as bytechr
from fontTools.misc.textTools import tobytes as tobytes
from fontTools.misc.textTools import tostr as tostr

log: Incomplete

class Parser:
    extensions: Incomplete
    ast: Incomplete
    SS_FEATURE_TAGS: Incomplete
    CV_FEATURE_TAGS: Incomplete
    glyphNames_: Incomplete
    doc_: Incomplete
    anchors_: Incomplete
    glyphclasses_: Incomplete
    lookups_: Incomplete
    valuerecords_: Incomplete
    symbol_tables_: Incomplete
    cur_comments_: Incomplete
    next_token_location_: Incomplete
    lexer_: Incomplete
    missing: Incomplete
    def __init__(
        self,
        featurefile,
        glyphNames=...,
        followIncludes: bool = ...,
        includeDir: Incomplete | None = ...,
        **kwargs
    ) -> None: ...
    def parse(self): ...
    def parse_anchor_(self): ...
    def parse_anchor_marks_(self): ...
    def parse_anchordef_(self): ...
    def parse_anonymous_(self): ...
    def parse_attach_(self): ...
    def parse_enumerate_(self, vertical): ...
    def parse_GlyphClassDef_(self): ...
    def parse_glyphclass_definition_(self): ...
    def split_glyph_range_(self, name, location): ...
    def parse_glyphclass_(self, accept_glyphname, accept_null: bool = ...): ...
    def parse_glyph_pattern_(self, vertical): ...
    def parse_chain_context_(self): ...
    def parse_ignore_(self): ...
    def parse_include_(self): ...
    def parse_language_(self): ...
    def parse_ligatureCaretByIndex_(self): ...
    def parse_ligatureCaretByPos_(self): ...
    def parse_lookup_(self, vertical): ...
    def parse_lookupflag_(self): ...
    def parse_markClass_(self): ...
    def parse_position_(self, enumerated, vertical): ...
    def parse_position_cursive_(self, enumerated, vertical): ...
    def parse_position_base_(self, enumerated, vertical): ...
    def parse_position_ligature_(self, enumerated, vertical): ...
    def parse_position_mark_(self, enumerated, vertical): ...
    def parse_script_(self): ...
    def parse_substitute_(self): ...
    def parse_subtable_(self): ...
    def parse_size_parameters_(self): ...
    def parse_size_menuname_(self): ...
    def parse_table_(self): ...
    def parse_table_GDEF_(self, table) -> None: ...
    def parse_table_head_(self, table) -> None: ...
    def parse_table_hhea_(self, table) -> None: ...
    def parse_table_vhea_(self, table) -> None: ...
    def parse_table_name_(self, table) -> None: ...
    def parse_name_(self): ...
    def parse_stat_name_(self): ...
    def parse_nameid_(self): ...
    def unescape_string_(self, string, encoding): ...
    @staticmethod
    def unescape_unichr_(match): ...
    @staticmethod
    def unescape_byte_(match, encoding): ...
    def parse_table_BASE_(self, table) -> None: ...
    def parse_table_OS_2_(self, table) -> None: ...
    def parse_STAT_ElidedFallbackName(self): ...
    def parse_STAT_design_axis(self): ...
    def parse_STAT_axis_value_(self): ...
    def parse_STAT_location(self): ...
    def parse_table_STAT_(self, table) -> None: ...
    def parse_base_tag_list_(self): ...
    def parse_base_script_list_(self, count): ...
    def parse_base_script_record_(self, count): ...
    def parse_device_(self): ...
    def is_next_value_(self): ...
    def parse_valuerecord_(self, vertical): ...
    def parse_valuerecord_definition_(self, vertical): ...
    def parse_languagesystem_(self): ...
    def parse_feature_block_(self, variation: bool = ...): ...
    def parse_feature_reference_(self): ...
    def parse_featureNames_(self, tag): ...
    def parse_cvParameters_(self, tag): ...
    def parse_cvNameIDs_(self, tag, block_name): ...
    def parse_cvCharacter_(self, tag): ...
    def parse_FontRevision_(self): ...
    def parse_conditionset_(self): ...
    def parse_block_(
        self,
        block,
        vertical,
        stylisticset: Incomplete | None = ...,
        size_feature: bool = ...,
        cv_feature: Incomplete | None = ...,
    ) -> None: ...
    def is_cur_keyword_(self, k): ...
    def expect_class_name_(self): ...
    def expect_cid_(self): ...
    def expect_filename_(self): ...
    cur_token_: Incomplete
    def expect_glyph_(self): ...
    def check_glyph_name_in_glyph_set(self, *names) -> None: ...
    def expect_markClass_reference_(self): ...
    def expect_tag_(self): ...
    def expect_script_tag_(self): ...
    def expect_language_tag_(self): ...
    def expect_symbol_(self, symbol): ...
    def expect_keyword_(self, keyword): ...
    def expect_name_(self): ...
    def expect_number_(self, variable: bool = ...): ...
    def expect_variable_scalar_(self): ...
    def expect_master_(self): ...
    def expect_any_number_(self): ...
    def expect_float_(self): ...
    def expect_decipoint_(self): ...
    def expect_stat_flags(self): ...
    def expect_stat_values_(self): ...
    def expect_string_(self): ...
    cur_token_type_: Incomplete
    def advance_lexer_(self, comments: bool = ...) -> None: ...
    @staticmethod
    def reverse_string_(s): ...
    def make_cid_range_(self, location, start, limit): ...
    def make_glyph_range_(self, location, start, limit): ...

class SymbolTable:
    scopes_: Incomplete
    def __init__(self) -> None: ...
    def enter_scope(self) -> None: ...
    def exit_scope(self) -> None: ...
    def define(self, name, item) -> None: ...
    def resolve(self, name): ...
