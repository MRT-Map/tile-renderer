from typing import NamedTuple

from _typeshed import Incomplete
from fontTools import ttLib as ttLib
from fontTools.feaLib.ast import STATNameStatement as STATNameStatement
from fontTools.misc.fixedTools import fixedToFloat as fixedToFloat
from fontTools.otlLib.error import OpenTypeLibError as OpenTypeLibError
from fontTools.otlLib.optimize.gpos import compact_lookup as compact_lookup
from fontTools.ttLib.tables import otBase as otBase
from fontTools.ttLib.tables.otBase import CountReference as CountReference
from fontTools.ttLib.tables.otBase import OTTableWriter as OTTableWriter
from fontTools.ttLib.tables.otBase import ValueRecord as ValueRecord
from fontTools.ttLib.tables.otBase import valueRecordFormatDict as valueRecordFormatDict

log: Incomplete

def buildCoverage(glyphs, glyphMap): ...

LOOKUP_FLAG_RIGHT_TO_LEFT: int
LOOKUP_FLAG_IGNORE_BASE_GLYPHS: int
LOOKUP_FLAG_IGNORE_LIGATURES: int
LOOKUP_FLAG_IGNORE_MARKS: int
LOOKUP_FLAG_USE_MARK_FILTERING_SET: int

def buildLookup(
    subtables, flags: int = ..., markFilterSet: Incomplete | None = ...
): ...

class LookupBuilder:
    SUBTABLE_BREAK_: str
    font: Incomplete
    glyphMap: Incomplete
    location: Incomplete
    lookupflag: int
    markFilterSet: Incomplete
    lookup_index: Incomplete
    def __init__(self, font, location, table, lookup_type) -> None: ...
    def equals(self, other): ...
    def inferGlyphClasses(self): ...
    def getAlternateGlyphs(self): ...
    def buildLookup_(self, subtables): ...
    def buildMarkClasses_(self, marks): ...
    def setBacktrackCoverage_(self, prefix, subtable) -> None: ...
    def setLookAheadCoverage_(self, suffix, subtable) -> None: ...
    def setInputCoverage_(self, glyphs, subtable) -> None: ...
    def setCoverage_(self, glyphs, subtable) -> None: ...
    def build_subst_subtables(self, mapping, klass): ...
    def add_subtable_break(self, location) -> None: ...

class AlternateSubstBuilder(LookupBuilder):
    alternates: Incomplete
    def __init__(self, font, location) -> None: ...
    def equals(self, other): ...
    def build(self): ...
    def getAlternateGlyphs(self): ...
    def add_subtable_break(self, location) -> None: ...

class ChainContextualRule:
    @property
    def is_subtable_break(self): ...

class ChainContextualRuleset:
    rules: Incomplete
    def __init__(self) -> None: ...
    def addRule(self, rule) -> None: ...
    @property
    def hasPrefixOrSuffix(self): ...
    @property
    def hasAnyGlyphClasses(self): ...
    def format2ClassDefs(self): ...

class ChainContextualBuilder(LookupBuilder):
    def equals(self, other): ...
    def rulesets(self): ...
    def getCompiledSize_(self, subtables): ...
    def build(self): ...
    def buildFormat1Subtable(self, ruleset, chaining: bool = ...): ...
    def buildFormat2Subtable(self, ruleset, classdefs, chaining: bool = ...): ...
    def buildFormat3Subtable(self, rule, chaining: bool = ...): ...
    def buildLookupList(self, rule, st) -> None: ...
    def add_subtable_break(self, location) -> None: ...
    def newSubtable_(self, chaining: bool = ...): ...
    def ruleSetAttr_(self, format: int = ..., chaining: bool = ...): ...
    def ruleAttr_(self, format: int = ..., chaining: bool = ...): ...
    def newRuleSet_(self, format: int = ..., chaining: bool = ...): ...
    def newRule_(self, format: int = ..., chaining: bool = ...): ...
    def attachSubtableWithCount_(
        self,
        st,
        subtable_name,
        count_name,
        existing: Incomplete | None = ...,
        index: Incomplete | None = ...,
        chaining: bool = ...,
    ): ...
    def newLookupRecord_(self, st): ...

class ChainContextPosBuilder(ChainContextualBuilder):
    rules: Incomplete
    subtable_type: str
    def __init__(self, font, location) -> None: ...
    def find_chainable_single_pos(self, lookups, glyphs, value): ...

class ChainContextSubstBuilder(ChainContextualBuilder):
    rules: Incomplete
    subtable_type: str
    def __init__(self, font, location) -> None: ...
    def getAlternateGlyphs(self): ...
    def find_chainable_single_subst(self, glyphs): ...

class LigatureSubstBuilder(LookupBuilder):
    ligatures: Incomplete
    def __init__(self, font, location) -> None: ...
    def equals(self, other): ...
    def build(self): ...
    def add_subtable_break(self, location) -> None: ...

class MultipleSubstBuilder(LookupBuilder):
    mapping: Incomplete
    def __init__(self, font, location) -> None: ...
    def equals(self, other): ...
    def build(self): ...
    def add_subtable_break(self, location) -> None: ...

class CursivePosBuilder(LookupBuilder):
    attachments: Incomplete
    def __init__(self, font, location) -> None: ...
    def equals(self, other): ...
    def add_attachment(self, location, glyphs, entryAnchor, exitAnchor) -> None: ...
    def build(self): ...

class MarkBasePosBuilder(LookupBuilder):
    marks: Incomplete
    bases: Incomplete
    def __init__(self, font, location) -> None: ...
    def equals(self, other): ...
    def inferGlyphClasses(self): ...
    def build(self): ...

class MarkLigPosBuilder(LookupBuilder):
    marks: Incomplete
    ligatures: Incomplete
    def __init__(self, font, location) -> None: ...
    def equals(self, other): ...
    def inferGlyphClasses(self): ...
    def build(self): ...

class MarkMarkPosBuilder(LookupBuilder):
    marks: Incomplete
    baseMarks: Incomplete
    def __init__(self, font, location) -> None: ...
    def equals(self, other): ...
    def inferGlyphClasses(self): ...
    def build(self): ...

class ReverseChainSingleSubstBuilder(LookupBuilder):
    rules: Incomplete
    def __init__(self, font, location) -> None: ...
    def equals(self, other): ...
    def build(self): ...
    def add_subtable_break(self, location) -> None: ...

class SingleSubstBuilder(LookupBuilder):
    mapping: Incomplete
    def __init__(self, font, location) -> None: ...
    def equals(self, other): ...
    def build(self): ...
    def getAlternateGlyphs(self): ...
    def add_subtable_break(self, location) -> None: ...

class ClassPairPosSubtableBuilder:
    builder_: Incomplete
    values_: Incomplete
    forceSubtableBreak_: bool
    subtables_: Incomplete
    def __init__(self, builder) -> None: ...
    classDef1_: Incomplete
    classDef2_: Incomplete
    def addPair(self, gc1, value1, gc2, value2) -> None: ...
    def addSubtableBreak(self) -> None: ...
    def subtables(self): ...
    def flush_(self) -> None: ...

class PairPosBuilder(LookupBuilder):
    pairs: Incomplete
    glyphPairs: Incomplete
    locations: Incomplete
    def __init__(self, font, location) -> None: ...
    def addClassPair(
        self, location, glyphclass1, value1, glyphclass2, value2
    ) -> None: ...
    def addGlyphPair(self, location, glyph1, value1, glyph2, value2) -> None: ...
    def add_subtable_break(self, location) -> None: ...
    def equals(self, other): ...
    def build(self): ...

class SinglePosBuilder(LookupBuilder):
    locations: Incomplete
    mapping: Incomplete
    def __init__(self, font, location) -> None: ...
    def add_pos(self, location, glyph, otValueRecord) -> None: ...
    def can_add(self, glyph, value): ...
    def equals(self, other): ...
    def build(self): ...

def buildSingleSubstSubtable(mapping): ...
def buildMultipleSubstSubtable(mapping): ...
def buildAlternateSubstSubtable(mapping): ...
def buildLigatureSubstSubtable(mapping): ...
def buildAnchor(
    x,
    y,
    point: Incomplete | None = ...,
    deviceX: Incomplete | None = ...,
    deviceY: Incomplete | None = ...,
): ...
def buildBaseArray(bases, numMarkClasses, glyphMap): ...
def buildBaseRecord(anchors): ...
def buildComponentRecord(anchors): ...
def buildCursivePosSubtable(attach, glyphMap): ...
def buildDevice(deltas): ...
def buildLigatureArray(ligs, numMarkClasses, glyphMap): ...
def buildLigatureAttach(components): ...
def buildMarkArray(marks, glyphMap): ...
def buildMarkBasePos(marks, bases, glyphMap): ...
def buildMarkBasePosSubtable(marks, bases, glyphMap): ...
def buildMarkLigPos(marks, ligs, glyphMap): ...
def buildMarkLigPosSubtable(marks, ligs, glyphMap): ...
def buildMarkRecord(classID, anchor): ...
def buildMark2Record(anchors): ...
def buildPairPosClassesSubtable(
    pairs,
    glyphMap,
    valueFormat1: Incomplete | None = ...,
    valueFormat2: Incomplete | None = ...,
): ...
def buildPairPosGlyphs(pairs, glyphMap): ...
def buildPairPosGlyphsSubtable(
    pairs,
    glyphMap,
    valueFormat1: Incomplete | None = ...,
    valueFormat2: Incomplete | None = ...,
): ...
def buildSinglePos(mapping, glyphMap): ...
def buildSinglePosSubtable(values, glyphMap): ...

class _DeviceTuple(NamedTuple):
    DeltaFormat: Incomplete
    StartSize: Incomplete
    EndSize: Incomplete
    DeltaValue: Incomplete

def buildValue(value): ...
def buildAttachList(attachPoints, glyphMap): ...
def buildAttachPoint(points): ...
def buildCaretValueForCoord(coord): ...
def buildCaretValueForPoint(point): ...
def buildLigCaretList(coords, points, glyphMap): ...
def buildLigGlyph(coords, points): ...
def buildMarkGlyphSetsDef(markSets, glyphMap): ...

class ClassDefBuilder:
    classes_: Incomplete
    glyphs_: Incomplete
    useClass0_: Incomplete
    def __init__(self, useClass0) -> None: ...
    def canAdd(self, glyphs): ...
    def add(self, glyphs) -> None: ...
    def classes(self): ...
    def build(self): ...

AXIS_VALUE_NEGATIVE_INFINITY: Incomplete
AXIS_VALUE_POSITIVE_INFINITY: Incomplete

def buildStatTable(
    ttFont,
    axes,
    locations: Incomplete | None = ...,
    elidedFallbackName: int = ...,
    windowsNames: bool = ...,
    macNames: bool = ...,
) -> None: ...
